# EC Webresource App

React + TypeScript template for Dynamics 365/Dataverse web resources. Generated by `create-ec-app`, it provides a lean setup with Vite, Tailwind CSS, and a choice of UI library (Kendo UI or Shadcn/ui), pre-configured for running inside Dynamics 365 and for local development.

## Features

- React + TypeScript with Vite (Client side only)
- Tailwind CSS configured out of the box
- UI library choice: Kendo UI (with theme selection) or Shadcn/ui
- TanStack Query provider pre-wired (`QueryClientProvider` in `src/main.tsx`)
- XRM-aware runtime: adds `ClientGlobalContext.js.aspx` and detects `window.Xrm`
- Local development via `token.json` (excluded from bundling) and helper functions
- Vite build tuned for web resources: single JS bundle, `main.css`, deterministic names
- Zustand and `@types/xrm` included for state and typings

## Prerequisites

- Node.js 22+ and npm 9+
- Dynamics 365/Dataverse environment for deployment
- Kendo UI license (only if you picked Kendo UI)

## Getting Started

- Install dependencies (if needed): `npm install`
- For Kendo UI projects, activate your license: `npx kendo-ui-license activate` (you need to copy over your kendo-license.txt to the root to activate or stick with non-premium components)
- Start dev server: `npm run dev`
- Production build: `npm run build`
- Development build (readable, no minify): `npm run build:dev`

## Key Files

- `src/main.tsx`: Sets up React, Tailwind, and TanStack Query. If Kendo UI was selected, imports the chosen theme CSS (`<theme>/dist/all.css`).
- `src/services/authService.ts`: Utilities to build API URLs and headers based on environment (inside Dynamics vs. local dev).
- `token.json`: Local development token store. Build is configured to treat this as external and not bundle it.
- `index.html`: Injects `ClientGlobalContext.js.aspx` for Dynamics runtime.
- `vite.config.ts`: Uses base `./`, disables code splitting, emits `main.css`, and places assets at the top of `dist`.

## Auth and API Access

The app auto-detects whether it runs inside Dynamics 365 (uses `window.Xrm` and does not add an Authorization header) or locally (reads a bearer token from `token.json`).

```ts
// src/services/authService.ts
export const getApiUrl = (): string => {
  if (window.parent && window.parent.Xrm) {
    const clientUrl = window.Xrm.Utility.getGlobalContext().getClientUrl();
    return `${clientUrl}/api/data/v9.2`;
  }
  return "https://DOMAIN.REGION.dynamics.com/api/data/v9.2";
};

export const getAuthHeaders = async (): Promise<HeadersInit> => {
  if (window.parent && window.parent.Xrm) {
    return {
      "Content-Type": "application/json",
      "OData-MaxVersion": "4.0",
      "OData-Version": "4.0",
      Prefer: 'odata.include-annotations="*"',
    };
  }
  const { default: token } = await import("../../token.json");
  return {
    Authorization: `Bearer ${token.accessToken}`,
    "Content-Type": "application/json",
    "OData-MaxVersion": "4.0",
    "OData-Version": "4.0",
    Prefer: 'odata.include-annotations="*"',
  };
};
```

Example usage:

```ts
import { getApiUrl, getAuthHeaders } from "@/services/authService";

const res = await fetch(`${getApiUrl()}/accounts?$top=10`, {
  headers: await getAuthHeaders(),
});
const data = await res.json();
```

## Azure CLI: Generate a Dataverse Token (Local Dev)

Use Azure CLI to obtain a bearer token for your Dataverse environment and paste it into `token.json` for local development.

Prerequisites:

- Azure CLI installed and you have access to the target tenant and environment.

Steps:

1. Sign in to Azure (optionally targeting a specific tenant):

```
az login --tenant <tenant-id>
```

2. Request an access token for your Dataverse environment URL (replace `<org>` and domain as applicable):

```
az account get-access-token \
  --tenant <tenant-id> \
  --resource https://<org>.crm.dynamics.com \
```

This prints the raw token to stdout. Copy it.

3. Paste the token value into `token.json` under `accessToken`:

```
{
  "accessToken": "<paste-token-here>",
  "expiresIn": "",
  "expires_on": 0,
  "subscription": "",
  "tenant": "",
  "tokenType": "Bearer"
}
```

Notes:

- Tokens expire; regenerate as needed. (Max expiry is 1 hour)
- If your CLI requires scopes, use `--scope https://<org>.crm.dynamics.com/.default` instead of `--resource`.

One‑liner (writes full JSON to `token.json`):

```
az account get-access-token --resource=https://<org>.crm.dynamics.com > token.json
```

Replace the URL with your environment’s Dataverse URL (e.g., `https://<org>.crm.dynamics.com`, `https://<org>.crm4.dynamics.com`, etc.). This overwrites `token.json` at the project root with the full output from Azure CLI, which includes `accessToken` used by the local dev flow.

## Accounts Data Service (TanStack Query)

The following example shows a minimal data service and hooks to fetch and update Accounts using the Dataverse Web API and TanStack Query.

Create `src/services/accounts.ts`:

```ts
import { getApiUrl, getAuthHeaders } from "@/services/authService";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";

export interface Account {
  accountid: string;
  name?: string | null;
  description?: string | null;
}

export const listAccounts = async (): Promise<Account[]> => {
  const res = await fetch(
    `${getApiUrl()}/accounts?$select=accountid,name,description&$top=50`,
    { headers: await getAuthHeaders() },
  );
  if (!res.ok) throw new Error(`Failed to fetch accounts: ${res.status}`);
  const json = await res.json();
  return json.value as Account[];
};

export const patchAccount = async (
  id: string,
  data: Partial<Account>,
): Promise<void> => {
  const headers = await getAuthHeaders();
  const res = await fetch(`${getApiUrl()}/accounts(${id})`, {
    method: "PATCH",
    headers: {
      ...headers,
    },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error(`Failed to update account: ${res.status}`);
};

export const useAccounts = () =>
  useQuery({ queryKey: ["accounts"], queryFn: listAccounts });

export const useUpdateAccount = () => {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: Partial<Account> }) =>
      patchAccount(id, data),
    onSuccess: () => {
      qc.invalidateQueries({ queryKey: ["accounts"] });
    },
  });
};
```

Usage in a component (e.g. `src/AccountsList.tsx`):

```tsx
import { useAccounts, useUpdateAccount } from "@/services/accounts";

export function AccountsList() {
  const { data, isLoading, error } = useAccounts();
  const updateAccount = useUpdateAccount();

  if (isLoading) return <div>Loading…</div>;
  if (error) return <div>Failed to load accounts</div>;

  return (
    <ul className="space-y-2">
      {data?.map((a) => (
        <li key={a.accountid} className="flex items-center gap-2">
          <span className="flex-1">{a.name ?? "(no name)"}</span>
          <button
            className="px-2 py-1 border rounded"
            onClick={() =>
              updateAccount.mutate({
                id: a.accountid,
                data: { name: `${a.name ?? ""}*` },
              })
            }
          >
            Rename
          </button>
        </li>
      ))}
    </ul>
  );
}
```

## UI Libraries

- Kendo UI: Theme CSS is imported in `src/main.tsx`. Example:

  ```tsx
  import { Button } from "@progress/kendo-react-buttons";
  <Button>Click me</Button>;
  ```

- Shadcn/ui: Components are installed and available under the `@/components` alias. Example:

  ```tsx
  import { Button } from "@/components/ui/button";
  <Button>Click me</Button>;
  ```

## Build Output

- Output directory: `dist`
- Single JavaScript bundle with deterministic name
- Single CSS file: `main.css`
- `base: "./"` to support deployment as a web resource

## Deployment

- Upload files from `dist` to Dynamics 365/Dataverse as web resources.
- Use `index.html` as the HTML web resource; upload the JS bundle and `main.css` as script/style web resources referenced by it.
- Consider automating uploads with your preferred tooling (DevOps pipelines, XrmToolBox, etc.).
- One quick and easy way to handle deployment is with Webresource Manager.
  - Open up webresource manager, and navigate to your specific solution
  - Create a new root (example GlobalAccounts*or CustomDev*)
  - Add a new folder for your webresources
  - Upload your index.html, index.js and main.css to your folder.
  - This will now allow you to use auto publisher to bind to your deployed resources.

## Notes

- If you change the build, ensure code splitting stays disabled and asset names remain predictable to simplify web resource updates.
